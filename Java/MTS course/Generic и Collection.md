Generic 
Придуманы, чтобы работать с разными типами данных унифицировано
На лекции пример с аккаунтом, в котором мы делаем id и строкой и числом

Можно использовать как интерфейс
Пример: отправщик - интерфейс, который позволяет отправлять что-либо
Наследники это банк, который отправляет деньги и почтальон, который отправляет письма

Generic method:
Пример использования: функция, возвращающая максимум из двух элементов
public static <T extends Comparable <>> T findMaxsimum

**WildCard**
Спец. символ обозначающийся вопросом и позволяющий делать ограничения на типы T
![[Pasted image 20240222183911.png]]


**Теорема PECS**
Producer Extends Consumer Super
Если есть коллекция и он ограничен верхней границей extends, то это Producer
Если есть коллекция и он ограничен нижней границей super, то это Consumer




**Extends**
Ограничение extends
Все элементы использующиеся в методе должны быть наследниками тех объектов указанных после extends

**Во время компиляции компилятор стирает и заменяет тип на object**
Но если указано например extends, то происходит замена на первый тип

**Особенности**
1)
2)Лучше использовать унификацию вместо wildcard



**Collection**
Для перебора элементов в коллекции есть интерфейс iterator
iterator()-метод возвращает объект класса iterator
Имеет методы :
1)next()-следующий элемент
2)hasNext()- проверка на существующий след. элемент
3)remove() - удаление элемента

Во время цикла прохода в коллекции нельзя изменять коллекцию(удалять, добавлять элементы)
Но можно попробовать удалить с помощью iteratora

<----------------------------------ArrayList----------------------------------->
Конструкторы:
1)Без параметров
2)С указанием capacity
3)С указанием коллекции другой
Представляет собой динамически изменяемые массив, то есть представляет собой обычный массив

При создании коллекции через of, например, List.of("1","2","3") она не изменяема

При достижении предела вызывается метод Grow() и создается новый массив с увеличенным capacity()

Для получения элементов, есть метод get 
number.get(0)

Для добавление новой коллекции можно использовать метод addAll 

Проверка есть ли элемент в коллекции, то можно использовать метод contains()

Получение индекса элемента - indexOf(Элемент, который мы ищем)

Удаление элементов
remove() - удаление одного элемента
removeAll() - удаление коллекции
Позволяет внутри себя хранить дубликаты

Удаление плохо работает в данной реализации, так как нужно сдвигать весь массив
<----------------------------------LinkedList----------------------------------->
Конструктор:
1)Без параметров
2)С указанием другой коллекции
Основное понятие для данного списка это node
У каждого элемента есть ссылка на предыдущий элемент и на следующий

При добавлении нода добавляется в конец и добавляются ссылки

Есть возможность добавлять в конец addLast()

Получение последнего и первого элементов getLast() ,getFirst()

Для поиска 9000 элемента нужно перебрать все элементы до 9000

Случаи работы по linked listу:
Быстрое удаление - перевязываем ссылки
Методы схожи с тем, что были в ArrayList<>()
<----------------------------------HashSet----------------------------------->
Конструкторы:
1)Без параметров
2)С capacity 
3)C capacity и loadFactor 
4)Collection
Внутри содержится HashMap

Для получение первого элемента можно сделать цикл с помощью самописных функций
Для хранения уникальных элементов
Достигается за счет работы с уникальными ключами
Метод retainAll -удаляет элемент

Особенность:
При добавлении дубликатов и null они будут добавлены один раз
<----------------------------------TreeSet----------------------------------->
Имплементация интерфейса navigableSet
Получаем возможность упорядочивания элементов
Конструкторы:
1)Без параметров
2)Передача компоратора
3)Коллекцию
4)Отсортированный SortedSet
Появляются удобные методы для получения первого и последнего элементов
При добавлении дубликатов выведет ошибку, так как не знает как сравнивать

Нужен для хранения уникальных элементов в алфавитном порядке

<----------------------------------HashMap----------------------------------->
Хранит key,value 
Конструкторы:
![[Pasted image 20240222194232.png]]
Емкость по умолчанию 16
Максимум 1 млрд
Коэффициент загрузки мапы для расширение коллекции
Количество элементов для преобразование связного списка в дерево: 8
Количество элементов для преобразование обратного преобразования: 6

**put**
При добавлении объекта вычисляется hash, так как там есть backet(корзины- место для объекта), происходит сравнение по equals
Для корректной работы hashMap нужно переопределять функции hashCode() и equals()
Есть методы для работы с ключами и значениями:
containsKey()
containsValue()

Метод получения по ключу
get()  - получение элемента
getOrDefault() - получение элемента или если его нет, то получение default

Метод для изменения мапы:
replace
При добавлении дубликатов и null:
Они добавляются один раз

<----------------------------------TreeMap----------------------------------->
Нужно добавить ей comparator для сравнения элементов
Есть возможность получение первого и последнего элемента 
Особенности для null и дублей:
Будет ошибка при добавлении таких элементов -null pointer exception

<----------------------------------Fifo Lifo----------------------------------->
First in first out 
ArrayDeque
Массив 
При добавлении null и дубликаты, NPE

Last In first out
Похоже на стопку
Стэк
Методы pop и peek
Null и дубликаты работают, добавляются 




